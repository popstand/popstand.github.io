{
  "name": "Popstand Git Workflow",
  "tagline": "public facing documentation",
  "body": "Following steps should be followed since inception of a feature request or a bug report in our issue tracker till the changes that adress it are deployed to our production infrastructure.\r\n\r\nThis workflow is based on [GitFlow Workflow](https://www.atlassian.com/pt/git/workflows#!workflow-gitflow). We are using different branch names and structure however to keep the workflow much more easir to understand.\r\n\r\nWe're using `master` in place of `develop` and `production` in place of `master`.\r\n\r\nSuppose an issue pops up in our issue tracker that clearly describes the feature or bug that has to be addressed. It is assigned to appropriate developer and is marked **Ready for Development**. Following are steps for different individuals in the lifecycle of the issue as they come in contact of the issue.\r\n\r\n### Developer\r\n\r\nA. The assigned developer creates a feature branch in the form of `XXX-some_description` off of `master`. Here `XXX` is the issue number e.g. `bilz-12`. This branch will accumulate all the commits addressing the issue in context.\r\n\r\n```\r\nmaster> git checkout -b bilz-12-user_registration\r\n```\r\n\r\nB. The developer starts working on the issue after understanding all the requirements and keeps pushing to the feature branch created in above step. S/he marks the issue to be **In Development**\r\n\r\n```\r\nbilz-12-user_registration> git commit -m \"Work done!\"\r\n```\r\n\r\nC. Once the developer is done with the work, s/he pushes the feature branch to origin and initiates a Pull Request with `master` as its base. The developer assigns the issue to someone appropriate and marks the issue to be in **Needs Code Review** phase.\r\n\r\n```\r\nbilz-12-user_registration> git push origin bilz-12-user_registration\r\n```\r\n\r\nD. Code reviewer reviews the code while making sure that all the tests pass and presense of test cases for new changes. If the review is not good, reviewer assigns the issue back to the developer with appropriate comments and marks the issue to be in **Ready for Development** phase again. The developer now starts at step **B** again.\r\n\r\nE. If the review is okay, the **original developer** should merge the feature branch in `master` using following flow **after** [squashing](http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html) all the new commits in a single commit. The issuse should now be marked **Ready for Staging** and assigned to a QA. If necessary, the developer should put a comment describing what part of the application should be tested and exactly how.\r\n\r\n```\r\ngit checkout bilz-12-user_registration      # Checkout the feature bra\r\ngit rebase -i HEAD~n                    # Squash all the commits. #n is the number of **new** commits on this branch.\r\ngit checkout master              \r\ngit pull origin master                  # Update master\r\ngit checkout bilz-12-user_registration      # Checkout the feature branch.\r\ngit rebase master                       # Rebase feature branch with master. Follow the rebase instructions to fix any conflicts.\r\ngit push -f origin bilz-12-user_registration # Update the pull request with rebased code.\r\ngit checkout master              \r\ngit merge bilz-12-user_registration         # Merge feature into master.\r\ngit push origin master                  # Push the code changes to origin.\r\n```\r\n**NOTE:** Squashing commits is extremely necessary. Unsquashed commits are very difficult to release to production because we can not revert them easily in case hell breaks upon us.\r\n\r\nF. An automated or manual system should deploy the `master` branch to our staging infrastructure. All the issues currently marked **Ready for Staging** should be marked **Ready for Testing**.\r\n\r\nG. QA should perform test on all the issues that are **Ready for Testing** and mark those as **In Testing**. if QA is not good, the issue is marked as **Ready for Development** and original developer start at step **B** again.\r\n\r\nH. If the QA is good, the feature branch should be deleted from the repository and QA should mark the issue as **Ready for Production** and assign the issue to a Release Manager.\r\n\r\n***\r\n\r\n### Releasing Code to Production\r\n\r\nWhen satisfactory number of issues in our tracker have been marked as **Ready for Production**, a release manager should deploy the changes to production infrastructure by following steps below.\r\n\r\nI. The Release Manager should create a new release branch off of `master` and give it an appropriate name in the form of `release-XYZ` where `XYZ` gives a meaningful name to the group of issues being released. The Release Manager makes sure all the automated tests pass. In case those don't, S/he should look out for appropriate developer who worked in the area in which the test is failing.\r\n\r\n```\r\nmaster> git checkout -b release-user_registration\r\nrelease-user_registration> git push origin release-user_registration\r\n```\r\n\r\nJ. In case the tests are failing or a bug crops up related to any issue being released, a new issue should be opened in the tracker and all the steps should be followed starting step **A** except in place of `master` current release branch should be used.\r\n\r\nK. In case everything looks good, the release branch should be merged to `production`. An annotated tag should be made with an appropriate version number that follows [Semantic Versioning Scheme](http://semver.org). This tag should be deployed to production infrastructure. The tag message should contain links to all the issues being deployed with this tag.\r\n\r\n```\r\nproduction> git tag -a 0.0.1\r\nproduction> git push --tags\r\n```\r\n\r\nL. The release branch should be merged back to `master`.\r\n\r\n```\r\nmaster> git merge release-user_registration\r\n```\r\n\r\nM. The release branch should be deleted from repository.\r\n\r\nN. All the \"Ready for Production\" issues should be marked **On Production** and assigned to QA.\r\n\r\nO. QA should do a smoke test all the issues and mark the issues as **Fixed**. In case a new bug is found, it should be put it in the queue of next or another appropriate release cycle.\r\n\r\n### Hot Fixes\r\n\r\nIn a critical bug pops up on production following steps should be taken to fix it.\r\n\r\nP. A new branch is created off of `production` and all the commits are made in this branch.\r\n\r\n```\r\nproduction> git checkout -b bilz-34-username_unique\r\n```\r\n\r\nQ. After code review and QA this branch is merged in `production` directly and a new tag is deployed to production infrastructure.\r\n\r\n```\r\nproduction> git merge bilz-34-username_unique\r\nproduction> bundle exec cap deploy production\r\n```\r\n\r\nR. This branch is merged back `master` and deleted.\r\n\r\n```\r\nmaster> git merge bilz-34-username_unique\r\n```\r\n\r\n***\r\n\r\n## Guidelines\r\n\r\nThere are a few guidelines that should be followed before committing your code changes to the repository.\r\n\r\n### JIRA Issue Number in Every Feature Branch\r\n\r\nEvery feature branch should have the JIRA issue number as its prefix. e.g. if you're working on the issue named `BILZ-23` which pertains to user registration, you should call your branch `bilz-23-user_registration`.\r\n\r\nThis practice right away tells us the issue which is being worked on the feature branch and lets us organize our branches for relase easily.\r\n\r\n### JIRA Issue number in every commit message\r\n\r\n*TL;DR:* A JIRA issue number should be present in every commit message. Suppose you're working on an issue which has number `BILZ-10`, every commit that you make should have that issue number somewhere in the commit message.\r\n\r\ne.g. `git commit -m \"(BILZ-23) User may now register\".\r\n\r\nAlthough we try to make sure that our commit messages are explanative but sometimes we do not write good commit messages. \"Fixes\" and \"Some minor refactorings\" are not good commit messages. Therefore we must add a JIRA issue number with every commit message. JIRA links the issue number with the corresponding issue in this project's issue list. This way even if a commit that does not have a good commit message, will lead to a JIRA issue. That issue will have explanation for which the commit was made. We can find out the reasons for which a change in code took place at any point of time.\r\n\r\nOne can put issue number anywhere in the commit message. But it is advised to put it at the beginning or at the end of the message. I(Waseem) myself prefer at the beginning of the message. Following is an example of a good commit message with issue number.\r\n\r\n\"(BILZ-23) Adds User#surf.\" OR \"Refactors App.Models.Storybook BILZ-23\"\r\n\r\nThe string that describes issue number should be of the form \"ISSUE #XXX\" where XXX is the issue number. It's important that we have a # before the number string else Github wont link it with corresponding issue.\r\n\r\nRemember a good commit message reflects a developer's good intentions. Including an issue number is not a substitute for a bad commit message.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}